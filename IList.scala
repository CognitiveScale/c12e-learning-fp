package com.c12e.learn


// Algebraic Data Type  - 80s, 90s - objects were compared to Abstract Data Types
// class Foooooooo(/*private members*/ private: Any)
// case class Foooooooooo2(/*private members*/ public_with_setters_and_getters: Any)


// binary compatibility - use abstract class instead of trait

// sealsed = all implementation needs to be in file  = get algebra because of this
// algebraic data types are "encoded" in scala with subtyping
// encoded -

// scala doesnt have algebraic data types be default - it has stuff that lets us simulate them
// sealed and case let us do that...

// Dont give too much semantic value to a type parameter - limits understanding of it
// Type parameters dont need to be one letter: A, B, C, can be words, but should easily be able to know whats a type and type param, thus
// dont use similar names for types and type parameters
// wont allow numbers....

sealed abstract class IList[A] {
    // reduce - fold makes sense on empty list, reduce doesnt, reduce very similar to fold right
    // can make fold for any data structure
    // def fold[B](ifNil: B, ifCons: (A, B) => B): B (Non Curried)
    def fold[B](ifNil: B)(ifCons: (A, B) => B): B =  // (Curried)
        this match {
            case INil() => ifNil
            case ICons(h, t) => ifCons(h, t.fold(ifNil)(ifCons))
        }
}

// why they are called algebras:
// limited
// sums of products

final case class INil[A] () extends IList[A]
final case class ICons[A] (head: A, tail: IList[A]) extends IList[A]
// if you subtype a case class, breaks some autogenerated methods, thus they have to be final
// case class makes pattern matching work

// similar to haskell's:
// data IList a = INil | ICons a (IList a)

// to infer that the data constuctor is not a type:
// typeclasses will look for implicits on companion objects
object IList {
    def nil[A]: IList[A] = INil()
    def cons[A](h: A, t: IList[A]): IList[A] = ICons(h, t)

    // folds yield id func when passed constructors
    def id[A](list: IList[A]: IList[A] =
        // if its not curried, need [A] on both
        // list.fold(nil[A], cons[A])
        list.fold(nil[A])(cons)

        // Note: when you curry you add more stuff on heap (intermediary functions i guess) so it might not be wise to curry everything
        // Note: currying allows us to do this: (this is because if a funciton takes only one arg in scala, we dont need to use the () to call it)
        // list.fold(nil[A]) {
        //     ... define function
        // }
}

// every fold,
// if you fold on your constructors, you get the original object back

// import ._  imports everything, where you use a value of IList, you get the value
// Where you use the type of IList, you get the type


// ... foldable doest have laws - have to concieve stuff, should have law above.

// // Wont work, gun should be different for every different a
// sealed trait SonOf[A]
// final case class something[A] extends SonOf[A]
// final case class gun() extends SonOf[A]
//
// // Need to make a covariant for this to work:
// sealed trait SonOf[+A]
// final case class something[A] extends SonOf[A]
// final case class gun() extends SonOf[Nothing]

// unapply meant for adts
// custom extractors - generally wrong way to think of design, master adts before we can custom make an unapply
// Using language features in clever way - not needed, use them how they were designed
// case and case classes designed for pattern matching

// console >>
//     import com.c12e.learning
//
//     INil[String]
//       => com.c12e.learn.INil[String]
//       com.c12e.learn.INil is not a type - INil should return an IList not an INil, if make case classes private, cant use them for pattern matching, but wont accidentally use data constructors as type s
// 	   IList.nil
//       => com.c12e.learn.IList[Nothing] = INil()


// in scala - memebers of a class are private
// in scala - memebers of a case class are public
// abstract - means hidden - info you dont know...
// abstract data types - really deep into the origin of CS

// algebraic data types

// Two possible places to put methods, on abstract class, or companion object
